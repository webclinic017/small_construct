# -*- coding: utf-8 -*-
"""Investment_Fundamentals_Data_Analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oK4JHk93PxtHbkaY2LiXZgs4pae8VHkq

# Investment_Fundamentals_and_Data_Analytics

## About
This course will take you on a journey where you'll learn how to code in Python. You will learn how to use Python in a real working environment and explore how Python can be applied in the world of Finance to solve portfolio optimization problems. The first part of the course is ideal for beginners and people who want to brush up on their Python skills. And then, once we have covered the basics, we will be ready to tackle financial calculations and portfolio optimization tasks. The Finance block of this course will teach you in-demand, real-world skills employers are looking for. This explains topics such as how to work with Python's conditional statements, functions, sequences, and loops, build investment portfolios, and more.

The code bundle for this video course is available at https://github.com/PacktPublishing/Python-for-Finance-Investment-Fundamentals-and-Data-Analytics

Style and Approach
This course will teach you Python programming and how to conduct real-world financial analysis in Python—in short, complete Python training. It is packed with step-by-step instructions, extensive case studies, training, and more. To use this course, you will need to install Anaconda; we show you how to do this in one of the first lectures in the course.

## Key Features

* Learn Python programming.
* Learn to conduct Real - World Financial Analysis in Python.
* A practical tutorial designed for programming beginners and aspiring data scientists.

## What You Will Learn

* Learn how to code in Python
* Take your career to the next level
* Work with Python's conditional statements, functions, sequences, and loops
* Work with scientific packages, such as NumPy
* Understand how to use the Pandas data analysis toolkit 
* Plot graphs with Matplotlib
* Use Python to solve real-world tasks
* Get a job as a data scientist with Python
* Acquire solid financial acumen
* Carry out in-depth investment analysis
* Build investment portfolios
* Calculate risk and return for individual securities
* Calculate risk and return for investment portfolios
* Apply best practices when working with financial data
* Use univariate and multivariate regression analysis
* Understand the Capital Asset Pricing model
* Compare securities in terms of their Sharpe ratio
* Perform Monte Carlo simulations
* Learn how to price options by applying the Black Scholes formula
* Be comfortable applying for a developer job in a financial institution

## Structured Sections

* Calculate & compare Rates of Return
* Measuring Investment Risk
* Using Regressions for Financial Analysis
* Markowitz Portfolio Optimization
* Capital Asset Pricing Model
* Multivariate Regression Analysis
* Monte Carlo Simulations as Decision-Making Tool

## References

We report here relevant references:
1. https://subscription.packtpub.com/video/application_development/9781789618976/81833/81850/what-does-the-course-cover
"""

import jupytemplate
print(jupytemplate.get_template_path())

"""# Setup

## Library_Import
We import all the required Python libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# 1 Data manipulation
import numpy as np
import pandas as pd
    # 4 Options for pandas
pd.options.display.max_columns = 50
pd.options.display.max_rows = 30

    # 8 Visualizations
import matplotlib.pyplot as plt
# %matplotlib inline
    # 11 More Visualizations
import chart_studio.plotly as py
import plotly
import plotly.tools as tls
import plotly.graph_objs as go
import plotly.offline as ply
plotly.offline.init_notebook_mode(connected=True)
    # 18 Cufflinks binds Plotly directly to pandas dataframes.
import cufflinks as cf
cf.go_offline(connected=True)
cf.set_config_file(theme='white')
from scipy import stats
import statsmodels
import statsmodels.api as sm

    # 23 Data Sources
import quandl
import yfinance as yf
from yahoofinancials import YahooFinancials
import requests
import alpha_vantage
from alpha_vantage.timeseries import TimeSeries
#import iex
import iexfinance
from iexfinance.stocks import Stock
from iexfinance.stocks import get_historical_data
from iexfinance.stocks import get_historical_intraday
from iexfinance.refdata import get_symbols
from iexfinance.data_apis import get_data_points
from iexfinance.data_apis import get_time_series
from iexfinance.altdata import get_social_sentiment
from iexfinance.altdata import get_ceo_compensation

# 41 MISC LIB IMPORTS
import locale
from datetime import date, datetime
from nsepy import get_history
import os
import time
import csv
import json
from patsy import dmatrices

    # 51

"""## Local_Library_Import
We import all the required local libraries libraries
"""

# Include local library paths
import sys

    # uncomment and fill to import local libraries
    
# sys.path.append('path/to/local/lib') 
# Import local libraries

"""## test
#####
"""

https://cloud.iexapis.com/GET /stock/{symbol}/balance-sheet





"""# Introduction To Pyton
* Some helpful tricks

1. Basic Pyton Sytax
2. Functions, Conditional Stmts, Sequences, Iterations
3. Advanced Aspects

## Basic Tricks
"""

# Indexing Elements
'Friday'[4]

# EXTRA LINE
print('hey how are \
you doing today')

# COMPARISON OPERATORS
print(10==20/2)
print(10!=10)
print(10!=15)
print(100>50)
print(100<50)
print(15>=10+10)
print(15<=10+5)

"""###  Lists"""

participants=['john', 'leila', 'maria', 'dwayne', 'george','catherine']
new=['jayci','gordon','zach','nicole']
participants

participants[1:3]

participants.sort()
new.sort()

new_list=[participants, new]
new_list

"""### Dictionaries"""

dict={'k1':'cat', 'k2': 'dog', 'k3':'mouse', 'k4':'fish'}
dict

dict['k3']

dict['k5']='parrot'
dict

dep_workers={'dep1':'peter','dep2':['jenifer','michael','tommy']}
dep_workers['dep2']

team={}
team['pt guard']='dirk'
team['shoot guard']='al'
team['sm fwd']='sean'
team['power fwd']='alex'
team['center']='hector'
print(team)
print(team['center'])
print(team.get('sm fwd'))
print(team.get('coach'))

"""## ITERATIONS IN PYTHON


* for loops
* while loops
* create lists with range
* 
*

### FOR LOOPS
"""

even=[0,2,4,6,8,10,12,16,18,20]
for n in even:
    print (n)

for n in even:
    print (n, end=' ')

"""### While Loop"""

x=20 
while x <=20:
    print (x, end=' '),
    x=x+2

while x <=20:
    print (x, end=' '),
    x+=2

"""### Create Lists with the range () Function
* range(start, stop, step)
* 
* start= first number in the list
* stop = last value +1
* step = distance between each two consecutive values
"""

range(10)

"""### ITERATING OVER DICTIONARIES"""

# DICTIONARIES CONTAINING THE SAME KEYS

prices={
    'box of spaghetti': 4,
    'lasagna': 5,
    'hamburger': 2
}
quantity={
    'box of spaghetti': 6,
    'lasagna': 10,
    'hamburger': 1
}

money_spent=0
for i in prices:
    money_spent=money_spent+(prices[i]*quantity[i])
    
print (money_spent)

"""## ADVANCED PYTHON TOOLS

* Object oriented programming
* modules and packages
* standard library
* importing modules
* must have packages for finance and data science
* working with arrays
* generating random numbers
* note using financial data
* sources of financial data
* accessing notebook files
* import and organizing data in python part 1
* import and organizing data in python part 2.A
* import and organizing data in python part 2.B
* import and organizing data in python part 3
* changing the index of time-series data
* restarting jupyter kernal

## importing modules methods
"""

import math

math.sqrt(16)

from math import sqrt
sqrt(25)

from math import sqrt as s
sqrt(49)

import math as m
m.sqrt(64)

from math import *
sqrt(81)

"""# MUST HAVE PACKAGES FOR FINANCE AND DATA SCIENCE"""

import numpy as np                         # package allowing us to work with multidimensional arrays
import pandas as pd                        # package allowint us to organize dat in a tabular form (labels/tables/ext) 
import matplotlib                          # package for 2D plotting designed for visualization of numpy computations
import math as m                           # mathmatical function
import random                              # invoies random number generator
import statsmodels                         # descriptive statistics, plotting functions, regressions
import pandas_datareader                   #

"""## ARRAYS
* datatype must be consistent throughout the array
"""

import numpy as np

a=np.array([[0,1,2,3],[4,5,6,7]])
print (a)
print('')

print(a.shape)
print('')

print(a[1,3])
print('')

print(a[1,3])
print('')

a[1,2]=8
print(a)
print('')

print(a[0])
print('')

print(a[0])
print('')

print(a[1])
print('')

b=np.array([3,5])
print(b)
print('')

"""## SOURCES OF FINANCIAL DATA

* API (Application Programming Interface) 

    * iex
    * morningstar
    * alpha vantage
    * quandl
    * yahoo
* csv = saved files from pandas_datareader

## Importing and Organizing Data in Python – part I
"""

import numpy as np
import pandas as pd

ser=pd.Series(np.random.random(5), name='Column 01')
print(ser)
print('')
print(ser[2])

from pandas_datareader import data as wb

PG=wb.DataReader('PG', data_source = 'yahoo', start='1995-01-01')
PG

"""## Importing and Organizing Data in Python – part II"""

import numpy as np
import pandas as pd
from pandas_datareader import data as wb

iex_api_key = 'pk_3e46a4b55bd04bd68bb778802602595b'

PG = wb.DataReader('PG', data_source = 'iex', start = '2015-01-01', api_key = iex_api_key)
PG

tickers=['PG', 'MSFT','T','F','GE']

new_data=pd.DataFrame()

for t in tickers:
    new_data[t] = wb.DataReader(t, data_source = 'iex', start = '2015-1-1', api_key=iex_api_key)['close']
    
new_data

"""## Importing and Organizing Data in Python – part III"""

import numpy as np
import pandas as pd
from pandas_datareader import data as wb
import quandl

quandl_api_key = 'dbyBuiq4bczbbuz9bA4t'

mydata_01 = quandl.get('FRED/GDP', api_key = quandl_api_key)
mydata_01

mydata_01.to_csv(r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example1.csv')

mydata_02 = pd.read_csv(r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example1.csv')
mydata_02

mydata_02.to_excel(r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example2.xlsx')
mydata_03 = pd.read_excel(r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example2.xlsx')
mydata_03

"""## Changing the Index of Your Time-Series Data"""

mydata_02 = pd.read_csv(
    r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example1.csv',
    index_col='Date')

mydata_02

mydata_02.to_excel(
    r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example2.xlsx')

mydata_03 = pd.read_excel(
    r'C:/Users/gordo/Programming/Data_Bank/PACKT/P_4_F_Investment_Fundamentals_Data_Analytics/example2.xlsx')

mydata_03

mydata_03 = mydata_03.set_index('Value')
mydata_03

"""# Calculating and Comparing Rates of Return in Python

* 

1. Considering both risk and return
2. What are we going to see next
3. Calculating a security's rate of return
1. Calculating a Security’s Rate of Return in Python – Simple Returns – Part I
2. Calculating a Security’s Rate of Return in Python – Simple Returns – Part II
3. Calculating a Security’s Return in Python – Logarithmic Returns
1. What is a portfolio of securities & how to calculate its RoR Calculating the RoR of a Portfolio of Securities
2. Calculating the Rate of Return of a Portfolio of Securities
3. Popular stock indices that can help us understand financial markets
3. Calculating the Rate of Return of Indices

## Rate Of Return
    * the total return of an investment ( buy a stock then sell it )
    * excludes transaction costs // dividends paid by company
* Whichever method use MUST REMAIN CONSISTENT THROUGHOUT CODE
* Always remember timeframe 
    - do not compare investments with different holding periods
    - convert daily/monthly/annual returns to same timeframe across investments being compared

##### SIMPLE Rate of Return (s_RoR) = [(ending price - beginning price) / beginning price]*100
* when dealing with MULTIPLE assets over the same timeframe 

##### LOGRITHMIC Rate of Return (log_RoR) = log(ending price / beginning price) = log(ending price) - log(beginning price)
* when dealing with SINGLE asset over time

##### ANNUAL RETURN (a_RoR) = [(daily_return +1)^365]*100                          * d_RoR = daily_return
* converts daily, monthly, quarterly returns into annual returns

## Calculating a Security’s Rate of Return in Python – Simple Returns – Part I
"""

# IMPORTING LIBRARIES/MODULES
import numpy as np
import pandas as pd
from pandas_datareader import data as wb
import matplotlib.pyplot as plt

    # IMPORTING DATA FROM YAHOO AND RETURNING ONLY THE 'Adj Close' COLUMN TO A DATAFRAME 
PG = wb.DataReader('PG', data_source = 'yahoo', start = '1995-1-1')
PG=pd.DataFrame(PG['Adj Close'])
PG

"""## SIMPLE RATE OF RETURN
* calculate Simple Rate of Return in a new column of the existing dataframe and title it S_RoR
* NaN stands for 'NOT A NUMBER'
"""

PG['S_RoR'] = (PG['Adj Close'] / PG['Adj Close'].shift(1)) - 1
PG

"""### Calculating a Security’s Rate of Return in Python – Simple Returns – Part II
* avg_RoR_d = Average Mean Rate of Return Per Day
"""

# PLOT THE DAILY SIMPLE RETURNS (S_RoR)
PG['S_RoR'].plot(figsize = ( 8, 5))
plt.show()

"""### Average-Daily-Mean RoR
* avg_RoR_d
"""

avg_RoR_d = PG['S_RoR'].mean()
avg_RoR_d

print('Average-Daily-Mean RoR: '+f'{avg_RoR_d:%}')
# f'{avg_RoR_d:%}'

"""### Average-Annual-Mean RoR - 
* avg_RoR_a
"""

avg_RoR_a = PG['S_RoR'].mean()*250
avg_RoR_a

print('Average-Annual-Mean RoR: ' + f'{avg_RoR_a:%}')
# f'{avg_RoR_a:%}'

"""##  Logarithmic Returns - 
* Calculating a Security’s Return in Python 
* log_RoR
"""

PG.head()

"""### COMPUTE LOG RETURNS FOR DAYS
* PG['log_RoR']
"""

PG['log_RoR'] = np.log(PG['Adj Close'] / PG['Adj Close'].shift(1))

PG['log_RoR']

"""### PLOT LOG RETURNS"""

PG['log_RoR'].plot(figsize = (8,5))
plt.show()

"""### DAILY LOG MEAN RATE OF RETURN
* log_RoR_d
"""

log_RoR_d = PG['log_RoR'].mean()
log_RoR_d
print('DAILY LOG MEAN RATE OF RETURN: ' + f'{log_RoR_d:%}')

"""### Annual-Log-Mean-Rate-of-Return
* log_RoR_a
"""

log_RoR_a = PG['log_RoR'].mean()*250
log_RoR_a

print('Annual-Log-Mean-Rate-of-Return: ' + f'{log_RoR_a:%}')
PG

print('')
print('Average-Annual-Mean RoR: ' + f'{avg_RoR_a:%}')
print('')
print('Annual-Log-Mean-Rate-of-Return: ' + f'{log_RoR_a:%}')

"""## Calculating the Rate of Return of a Portfolio of Securities"""

tickers = ['PG', 'MSFT', 'F', 'GE']

mydata=pd.DataFrame()

for t in tickers:
    mydata[t] = wb.DataReader(t, data_source='yahoo', start='1995-1-1')['Adj Close']
    
mydata

mydata.info()

"""### NORMALIZATION TO 100:
* (Pt /Po)*100
"""

mydata.iloc[0]

# COMPARE ALL STOCKS AS IF ALL STARTING FROM THE SAME VALUE '100'
(mydata / mydata.iloc[0] * 100).plot(figsize=(15,6))
plt.show()

# IF DO NOT SET EQUAL TO 100 IT PULLS ALL FROM START DATE
mydata.plot(figsize=(15,6))
plt.show()

# .loc requirements = 'dates'

mydata.loc['1995-01-03']

"""## Rate of Return of a Portfolio of Securities
* Port_RoR = AVERAGE DAILY MEAN RATE OF RETURN
* A_Port_RoR = AVERAGE ANNUAL MEAN RATE OF RETURN

### AVERAGE DAILY MEAN RATE OF RETURN
* Port_RoR =
"""

Port_RoR = (mydata / mydata.shift(1))-1
Port_RoR

"""### AVERAGE ANNUAL MEAN RATE OF RETURN
* A_Port_RoR
"""

# ADD WEIGHTS INTO POSITONS
weights = np.array([0.25, 0.25, 0.25, 0.25])

np.dot(Port_RoR, weights)

# AVERAGE ANNUAL MEAN RATE OF RETURN
A_Port_RoR = Port_RoR.mean()*250
A_Port_RoR

np.dot(A_Port_RoR, weights)

pfolio_1 = 'The Annual Rate of Return For The Portfolio of Securities: '+str(round(np.dot(A_Port_RoR, weights), 5)*100)+'%'
pfolio_1

"""## Calculating the Rate of Return of Indices"""

tickers =['^GSPC', '^IXIC', '^GDAXI']

ind_data=pd.DataFrame()

for t in tickers:
    ind_data[t] = wb.DataReader(t, data_source='yahoo', start='1997-1-1')['Adj Close']
    
ind_data

# PLOT DATA
(ind_data / ind_data.iloc[0]*100).plot(figsize=(15,6))
plt.show()

# CALC AVERAGE DAILY MEAN RATES OF RETURNS 
ind_RoR = (ind_data / ind_data.shift(1)) -1
ind_RoR

# CALC AVERAGE ANNUAL MEAN RoR
ind_RoR_A = ind_RoR.mean()*250
ind_RoR_A

"""### BENCHMARKING"""

tickers =['PG','^GSPC', '^DJI','^IXIC', '^GDAXI']

ind_data2=pd.DataFrame()

for t in tickers:
    ind_data2[t] = wb.DataReader(t, data_source='yahoo', start='2007-1-1')['Adj Close']
    
ind_data2

(ind_data2 / ind_data2.iloc[0]).plot(figsize = (15,6))
plt.show()

"""#  Measuring Investment Risk
* 

* How do we measure a security's risk
* Calculating a Security’s Risk in Python
* The benefits of portfolio diversification
* Calculating the covariance between securities
* Measuring the correlation between stocks
* Calculating Covariance and Correlation
* Considering the risk of multiple securities in a portfolio
* Calculating Portfolio Risk
* Understanding Systematic vs. Idiosyncratic risk
* Calculating Diversifiable and Non-Diversifiable Risk of a Portfolio

## Calculating a Security’s Risk in Python
*
"""

tickers =['PG','BEI.DE']

sec_data=pd.DataFrame()

for t in tickers:
    sec_data[t] = wb.DataReader(t, data_source='yahoo', start='2007-1-1')['Adj Close']
    
sec_data

# CALC LOG RETURNS
sec_RoR = np.log(sec_data / sec_data.shift(1))
sec_RoR

"""### PG (DAILY ROR / ANNUAL ROR / STD)"""

# DAILY MEAN ROR
sec_RoR['PG'].mean()
sec_RoR_D = sec_RoR['PG'].mean()

    # ANNUAL MEAN ROR
sec_RoR_A = sec_RoR['PG'].mean()*250

    # STD DAILY
sec_RoR['PG'].std()

    # STD ANNUAL
sec_RoR_A_std = sec_RoR['PG'].std()*250**0.5

print('Annual STD: ' + f'{sec_RoR_A_std:%}')
print('')
print('Daily-Log-Mean-RoR: ' + f'{sec_RoR_D:%}')
print('')
print('Annual-Log-Mean-RoR: ' + f'{sec_RoR_A:%}')

"""### Beiersdorf (DAILY ROR / ANNUAL ROR / STD)"""

# DAILY MEAN ROR
sec_RoR['BEI.DE'].mean()
sec_RoR_D = sec_RoR['BEI.DE'].mean()

    # ANNUAL MEAN ROR
sec_RoR_A = sec_RoR['BEI.DE'].mean()*250

    # STD DAILY
sec_RoR['BEI.DE'].std()

    # STD ANNUAL
sec_RoR_A_std = sec_RoR['BEI.DE'].std()*250**0.5

print('Annual STD: ' + f'{sec_RoR_A_std:%}')
print('')
print('Daily-Log-Mean-RoR: ' + f'{sec_RoR_D:%}')
print('')
print('Annual-Log-Mean-RoR: ' + f'{sec_RoR_A:%}')

"""## Calculating Covariance and Correlation
*

### Variance Daily
"""

PG_var = sec_RoR['PG'].var()
print('PG_var '+'Daily_Variance: ' + f'{PG_var:%}')
print('')

BEI_var = sec_RoR['BEI.DE'].var()
print('BEI_var '+'Daily_Variance: ' + f'{BEI_var:%}')

"""### Variance Annually"""

PG_var_A = sec_RoR['PG'].var()*250
print('PG_var_A '+'Daily_Variance: ' + f'{PG_var_A:%}')
print('')

BEI_var_A = sec_RoR['BEI.DE'].var()*250
print('BEI_var_A '+'Daily_Variance: ' + f'{BEI_var_A:%}')

"""## Covariance Matrix
*
"""

# DAILY COVARIANCE MATRIX
cov_matrix_D = sec_RoR.cov()
cov_matrix_D

# ANNUAL COVARIANCE MATRIX
cov_matrix_A = sec_RoR.cov()*250
cov_matrix_A

"""## CORRELATION Matrix
*
"""

# DAILY CORRELATION MATRIX
corr_matrix_D = sec_RoR.corr()
corr_matrix_D

"""## Calculating Portfolio Risk
*
"""

# EQUAL WEIGHT SCHEME:
    
weights = np.array([0.5, 0.5])

# PORTFOLIO VARIANCE:
    
pfolio_var = np.dot(weights.T, np.dot(sec_RoR.cov()*250, weights))
print('PORTFOLIO_Variance = ' + f'{pfolio_var:%}')

# PORTFOLIO VOLATILITY:
    
pfolio_vol = np.dot(weights.T, np.dot(sec_RoR.cov()*250, weights))**0.5
print('PORTFOLIO_VOLATILITY = ' + f'{pfolio_vol:%}')

"""## Calculating Diversifiable and Non-Diversifiable Risk of a Portfolio
*
"""

weights = np.array([0.5, 0.5])

weights[0]
weights[1]

"""### DIVERSIFIABLE_RISK:"""

PG_var_A = sec_RoR[['PG']].var()*250
PG_var_A


BEI_var_A = sec_RoR[['BEI.DE']].var()*250
BEI_var_A

pg_var_a = (weights[0]**2*PG_var_A)
pg_var_a=float(pg_var_a)


bei_var_a = (weights[1]**2*BEI_var_A)
bei_var_a=float(bei_var_a)


pfolio_var=float(pfolio_var)

dr = pfolio_var - pg_var_a - bei_var_a
print('ANNUAL_DIVERSIFIABLE_RISK = ' + f'{dr:%}')

"""### NON-DIVERSIFIABLE RISK:"""

n_dr_1 = pfolio_var - dr
print('ANNUAL_NON-DIVERSIFIABLE RISK = ' + f'{n_dr_1:%}')

pg_n_dr_2 = (weights[0]**2*PG_var_A)
pg_n_dr_2 = float(pg_var_a)


bei_n_dr_2 = (weights[1]**2*BEI_var_A)
bei_n_dr_2=float(bei_var_a)

n_dr_2 = pg_n_dr_2 + bei_n_dr_2

print('ANNUAL_NON-DIVERSIFIABLE RISK = ' + f'{n_dr_2:%}')

n_dr_1 == n_dr_2

"""#  Using Regressions for Financial Analysis
* some short description about this section

* The fundamentals of simple regression analysis
* Running a Regression in Python
* Are all regressions created equal? Learning how to distinguish good regressions
* Computing Alpha, Beta, and R Squared in Python

## Running a Regression in Python
*
"""

tickers =['AMZN','GOOG']

reg_data = pd.DataFrame()

for t in tickers:
    reg_data[t] = wb.DataReader(t, data_source='yahoo', start='2007-1-1')['Adj Close']
    
reg_data

reg_data[['AMZN', 'GOOG']]

"""## UNIVARIATE REGRESSION"""

# data[['Close', 'Adj Close']]

X = reg_data['GOOG']
Y = reg_data['AMZN']

# X
# Y

plt.scatter(X, Y)
plt.show()

plt.scatter(X, Y)
plt.axis([0,2000,0,3000])
plt.show()

plt.scatter(X, Y)
plt.axis([0,1500,0,2000])
plt.ylabel('AMZN')
plt.xlabel('GOOG')
plt.show()

"""##  Alpha, Beta, and R^2"""

X1 = sm.add_constant(X)

reg = sm.OLS(Y, X1).fit()

reg.summary()

"""### EXPECTED VALUE OF Y:"""

A = 365.3129       # COER /CONSTANT ^
B = 1.6386         # GOOG / CORR ^

Y_est=(A + B)
print('EXPECTED VALUE OF Y = ' + f'{Y_est:,}')

"""### ALPHA, BETA, R^2"""

slope, intercept, r_value, p_value, std_err = stats.linregress(X,Y)

slope

intercept

r_value

r_value**2

p_value

std_err

"""# Markowitz Portfolio Optimization
*

* Markowitz Portfolio theory – One of the main pillars of modern Finance
* Obtaining the Efficient Frontier in Python – Part I
* Obtaining the Efficient Frontier in Python – Part II
* Obtaining the Efficient Frontier in Python – Part III

## Obtaining the Efficient Frontier - Part I
"""

assets = ['PG','^GSPC']

pf_data = pd.DataFrame()

for a in assets:
    pf_data[a] = wb.DataReader(a, data_source='yahoo', start='2010-1-1')['Adj Close']

pf_data

(pf_data / pf_data.iloc[0]*100).plot(figsize = (10,5))

log_returns = np.log(pf_data / pf_data.shift(1))

log_returns.mean()*250

log_returns.cov()*250

log_returns.corr()

num_assets = len(assets)

arr = np.random.random(2)

arr[0] + arr[1]

weights = np.random.random(num_assets)
weights /= np.sum(weights)
weights

weights[0] + weights[1]

"""## Obtaining the Efficient Frontier–Part II

### EXPECTED PORTFOLIO RETURN:
"""

port_est_ror = np.sum(weights * log_returns.mean())*250

print('EXPECTED PORTFOLIO RETURN = ' + f'{port_est_ror:%}')

"""### EXPECTED PORTFOLIO VARIANCE"""

port_est_var = np.dot(weights.T, np.dot(log_returns.cov()*250, weights))

print('EXPECTED PORTFOLIO VARIANCE = ' + f'{port_est_var:%}')

"""### EXPECTED PORTFOLIO VOLATILITY"""

port_est_vol = np.sqrt(np.dot(weights.T, np.dot(log_returns.cov()*250, weights)))

print('EXPECTED PORTFOLIO VARIANCE = ' + f'{port_est_vol:%}')

pfolio_returns =[]
pfolio_volatilities =[]

for x in range (1000):
    weights = np.random.random(num_assets)
    weights /= np.sum(weights)
    pfolio_returns.append(np.sum(weights*log_returns.mean())*250)
    pfolio_volatilities.append(np.sqrt(np.dot(weights.T, np.dot(log_returns.cov()*250,weights))))
    
pfolio_returns, pfolio_volatilities

pfolio_returns =[]
pfolio_volatilities =[]

for x in range (1000):
    weights = np.random.random(num_assets)
    weights /= np.sum(weights)
    pfolio_returns.append(np.sum(weights*log_returns.mean())*250)
    pfolio_volatilities.append(np.sqrt(np.dot(weights.T, np.dot(log_returns.cov()*250,weights))))
    
pfolio_returns = np.array(pfolio_returns)
pfolio_volatilities = np.array(pfolio_volatilities)
    
pfolio_returns, pfolio_volatilities

"""## Obtaining the Efficient Frontier – Part III"""

portfolios = pd.DataFrame({'Return': pfolio_returns, 'Volatility': pfolio_volatilities})
portfolios

portfolios.plot(x='Volatility', y='Return', kind='scatter', figsize=(10,6));
plt.xlabel('Expected Volatility')
plt.ylabel('Expected Return')

"""# The Capital Asset Pricing Model
* 

* The intuition behind the Capital Asset Pricing Model (CAPM)
* Understanding and calculating a security's Beta
* Calculating the Beta of a Stock
* The CAPM formula
* Calculating the Expected Return of a Stock (CAPM)
* Introducing the Sharpe ratio and the way it can be applied in practice
* Obtaining the Sharpe ratio in Python
* Measuring alpha and verifying how good (or bad) a portfolio manager is doing

## Calculating Beta of a Stock
"""

rea

# LOG RETURN
sec_returns = np.log(data / data.shift(1))

    # COVARIANCE
cov = sec_returns.cov()*250

    # COVARIANCE with market
cov_w_mkt = cov.iloc[0,1]
    
    # MARKET VARIANCE
mkt_var = sec_returns['^GSPC'].var()*250

"""### BETA:"""

PG_beta = cov_w_mkt / mkt_var
PG_beta

"""## (CAPM)
* Calculating the Expected Return of a Stock
* = Risk_Free_Rate + Beta(risk_premium - risk free rate)
* = alpha + rf + B * (rm - rf)

    - alpha = alpha
    - rf = risk free rate
    - B = beta
    - rm = 
    - (rm-rf) = equity risk premium
  
 * assumes alpha = 0
"""

PG_er = 0.025 + PG_beta * 0.05
PG_er

"""## Obtaining the Sharpe ratio
* = (risk... - risk free rate) / std pg
"""

Sharpe = (PG_er - 0.025) / (sec_returns['PG'].std()*250**0.5)
Sharpe

print('Sharpe Ratio = ' + f'{Sharpe:%}')

"""# Multivariate regression analysis
* 

* Multivariate regression analysis - a valuable tool for finance practitioners
* Running a multivariate regression in Python
"""

import numpy as np 
import pandas as pd
from scipy import stats
import statsmodels.api as sm
import matplotlib.pyplot as plt

data = pd.read_csv(r'C:/Users/gordo/Programming/Education/Packt/Hands-on-P_4_F/Section 5/housing.csv')
data['Year_of_Construction']=2020-data['Age']
data['Rooms']=data['Features']
data['Price']=data['Price (00s)']
data=data[['Price', 'SqFt','Rooms','Cust','Corner', 'Tax', 'Year_of_Construction']]
data

"""## Multivariate Regression:"""

X = data[['SqFt', 'Rooms','Year_of_Construction']]
Y = data[['Price']]

X1 = data[['SqFt', 'Rooms']]
reg = sm.OLS(Y, X1).fit()

reg.summary()

"""### Independent Variables:
##### SqFt vs Rooms
"""

X = data[['SqFt', 'Rooms']]
Y = data[['Price']]

X1 = sm.add_constant(X)
reg = sm.OLS(Y, X1).fit()

reg.summary()

"""# Monte Carlo simulations as a decision-making tool
* Monte Carlo = MC

* The essence of Monte Carlo simulations
* Monte Carlo applied in a Corporate Finance context
* Monte Carlo: Predicting Gross Profit – Part I
* Monte Carlo: Predicting Gross Profit – Part II
* Forecasting Stock Prices with a Monte Carlo Simulation
* Monte Carlo: Forecasting Stock Prices - Part I
* Monte Carlo: Forecasting Stock Prices - Part II
* Monte Carlo: Forecasting Stock Prices - Part III
* An Introduction to Derivative Contracts
* The Black Scholes Formula for Option Pricing
* Monte Carlo: Black-Scholes-Merton
* Monte Carlo: Euler Discretization - Part I
* Monte Carlo: Euler Discretization - Part II

## MC: Predicting Gross Profit – Part I
"""

import numpy as np
import matplotlib.pyplot as plt

rev_m = 170
rev_stdev = 20
iterations = 1000

rev = np.random.normal(rev_m, rev_stdev, iterations)
rev

plt.figure(figsize = (15, 6))
plt.plot(rev)
plt.show()

# COGS ~= aprox. 60% of revenues
    # of that 60% we expect it will fall within 10% std

COGS = - (rev * np.random.normal(0.6, 0.1))

plt.figure(figsize=(15, 6))
plt.plot(COGS)
plt.show()

COGS.mean()

COGS.std()

"""## MC: Predicting Gross Profit – Part II"""

Gross_Profit = rev + COGS
Gross_Profit

plt.figure(figsize=(15, 6))
plt.plot(Gross_Profit)
plt.show()

max(Gross_Profit)

min(Gross_Profit)

Gross_Profit.mean()

Gross_Profit.std()

plt.figure(figsize=(10, 6))
plt.hist(Gross_Profit, bins = [40, 50, 60, 70, 80, 90, 100, 110, 120]);
plt.show()

plt.figure(figsize=(10, 6))
plt.hist(Gross_Profit, bins = 20);
plt.show()

"""## MC: Forecasting Stock Prices - Part I"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from pandas_datareader import data as wb
import matplotlib.pyplot as plt
from scipy.stats import norm
# %matplotlib inline

ticker = 'PG'

data1 = pd.DataFrame()

data1[ticker] = wb.DataReader(ticker, data_source='yahoo', start='2007-1-1')['Adj Close']
data1

# LOG RETURN
    
log_return1 = np.log(1+data1.pct_change())
log_return1

data1.plot(figsize=(10, 6));
log_return1.plot(figsize=(10, 6))

u = log_return1.mean()
u

var = log_return1.var()
var

drift = u - (0.5 * var)
drift

stdev = log_return1.std()
stdev

"""## MC: Forecasting Stock Prices - Part II"""

type(drift)

type(stdev)

"""## SETTING UP NUMPY ARRAY"""

np.array(drift)

drift.values

stdev.values

norm.ppf(0.95)

x = np.random.rand(10, 2)
x

norm.ppf(x)

Z = norm.ppf(np.random.rand(10, 2))
Z

t_intervals = 1000
iterations = 10

daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))

daily_returns

"""## MC: Forecasting Stock Prices - Part III"""

S0 = data1.iloc[-1]
S0

price_list = np.zeros_like(daily_returns)
price_list

price_list[0] = S0
price_list

price_list[0] = S0
price_list

for t in range(1, t_intervals):
    price_list[t] = price_list[t-1] * daily_returns[t]

price_list

plt.figure(figsize=(10, 6))
plt.plot(price_list);

"""# Introduction to Derivative Contracts
* A financial instrument whose price is derived based on the development of one or more underlying assets
* Originally, served as a hedging instrument
## Types:

##### OPTIONS
* Grants owner the right but not obligation to exercise (buy/sell) an underlying asset at a specificed price/time
    * AKA STRIKE PRICE
* MATURITY DATE = date upon which the option can be exercised 
* CALL OPTIONS = option to buy an asset
* PUT OPTION = option to sell an asset
       
##### FORWARDS
* less formal future
##### SWAPS
* 2 parties agree to exchange cash flows based on an underlying asset
* int rate / bond price / stock price / commodity
* most common is INTEREST RATE SWAP
        - exchange fixed rate to other party
        - for return of variable rate on that investment 
        - settle only the difference between the cash flows
##### FUTURES
* level of standardization between this and forwards

### OPTIONS - 
#### Key Terms:
* STRIKE PRICE = Grants owner the right but not obligation to exercise (buy/sell) an underlying asset at a specificed price
* MATURITY DATE = date upon which the option can be exercised 
* CALL OPTIONS = option to buy an asset
* PUT OPTION = option to sell an asset
       
#### CALL OPTION PAYOFF: (STRIKE PRICE VS SHARE PRICE)
* SHARE PRIVE > STRIKE PRICE = EXERCISE
* STRIKE PRICE > SHARE PRICE = DO NOT EXERCISE

# The Black Scholes Formula for Option Pricing
* designed to calculate the value of a CALL option by:
    - taking the difference between the amount you get if you exercise the option minus the amount you have to pay if you exercise the option
    
## Variables:
* s = current stock price
* K = option strike price
* t = time until maturity
* r = risk free int rate
* N = standard normal distributino
* e = exponential term
* C = call premium

## Monte Carlo: Black-Scholes-Merton
"""

import numpy as np
import pandas as pd
from pandas_datareader import data as wb
from scipy.stats import norm

def d1(S, K, r, stdev, T):
    return (np.log(S/K)+(r+stdev**2/2)*T)/(stdev*np.sqrt(T))

def d2(S, K, r, stdev, T):
    return (np.log(S/K)+(r-stdev**2/2)*T)/(stdev*np.sqrt(T))

norm.cdf(0)

norm.cdf(0.25)

norm.cdf(0.75)

norm.cdf(9)

def BSM(S, K, r, stdev, T):
    return (S*norm.cdf(d1(S, K, r, stdev, T)))-(K*np.exp(-r*T)*norm.cdf(d2(S, K, r, stdev, T)))

ticker = 'PG'
data = pd.DataFrame()
data[ticker]=wb.DataReader(ticker,data_source='yahoo',start='2007-1-1', end='2017-3-21')['Adj Close']

S = data.iloc[-1]
S

log_returns = np.log(1+data.pct_change())
log_returns

stdev = log_returns.std()*250**0.5
stdev

r = 0.025
K = 110.0
T = 1

d1(S, K, r, stdev, T)

d2(S, K, r, stdev, T)

BSM(S, K, r, stdev, T)

"""## Monte Carlo: Euler Discretization - Part I
*
"""

ticker = 'PG'
data = pd.DataFrame()
data[ticker]=wb.DataReader(ticker,data_source='yahoo',start='2007-1-1',end='2017-3-21')['Adj Close']

log_returnss= np.log(1+ data.pct_change())

r = 0.025

stdev = log_returns.std()*250**0.5
stdev

type(stdev)

stdev=stdev.values
stdev

T = 1.0
t_intervals = 250
delta_t = T/t_intervals

iterations =10000

Z = np.random.standard_normal((t_intervals+1, iterations))
S = np.zeros_like(Z)
S0 = data.iloc[-1]
S[0] = S0

for t in range(1, t_intervals + 1):
    S[t] = S[t-1]*np.exp((r-0.5*stdev**2)*delta_t+stdev*delta_t**0.5*Z[t])
    
S

S.shape

plt.figure(figsize=(10,6))
plt.plot(S[:, :10]);

"""## Monte Carlo: Euler Discretization - Part II
* p = PAYOFF
    -generate array to scope potential likelihood of payoff amounts
"""

p = np.maximum(S[-1]-110,0)
p

p.shape

# SHOULD RESULT IN A PROJECTED CALL OPTION PRICE NEAR THE BSM CALCULATED PRICE FROM BLACK SCHOLES MODEL 

C = np.exp(-r*T)*np.sum(p)/iterations
C



