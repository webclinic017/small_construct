# -*- coding: utf-8 -*-
"""GDP_1334_RESOURCE_GUIDE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uZCD0A-CIW_fqnDfSH5acl31XMsmbcbq

# TITLE: RESOURCE GUIDE:

## Module & Library Import
"""

!pip install yfinance
!pip install yahoofinancials
!pip install quandl
!pip install alpha_vantage

# Commented out IPython magic to ensure Python compatibility.
# 1 Data manipulation
import numpy as np
from bs4 import BeautifulSoup as bs
import pandas as pd
import pandas_datareader
from pandas_datareader import data as web
    # 7 Options for pandas
pd.options.display.max_columns = 50
pd.options.display.max_rows = 30

    # 11 Visualizations
import matplotlib.pyplot as plt
# %matplotlib inline
    # 14 More Visualizations
import chart_studio.plotly as py
import plotly
import plotly.tools as tls
import plotly.graph_objs as go
import plotly.offline as ply
plotly.offline.init_notebook_mode(connected=True)
    # 21 Cufflinks binds Plotly directly to pandas dataframes.
import cufflinks as cf
cf.go_offline(connected=True)
cf.set_config_file(theme='white')
 
    # 26 IMPORT API FUNCTIONS
import quandl
import yfinance as yf
from yahoofinancials import YahooFinancials
import requests
import alpha_vantage
from alpha_vantage.timeseries import TimeSeries


    # 44 MISC LIB IMPORTS
import locale
from datetime import date, datetime
import os
import time
import csv
import json
from patsy import dmatrices

    # 54

"""## Local library import
We import all the required local libraries libraries
"""

# Include local library paths
import sys

    # uncomment and fill to import local libraries
    
# sys.path.append('path/to/local/lib') 
# Import local libraries

"""# References

* import jupytemplate
* print(jupytemplate.get_template_path())

# GENERAL TRICKS:

## Format Outputs
* ADD COMMAS TO NUMBERS
"""

# ADD COMMAS TO NUMBERS\

value=100000000000000000
    
print('$'+f'{value:,}')


print('ANNUAL_NON-DIVERSIFIABLE RISK = ' + f'{value:%}')

"""# Data import
* We retrieve all the required data for the analysis.

## save data
"""

data.to_csv(r'C:\Users\gordo\Programming\Data_Bank\New_bank\_'+stocks+'.csv')
            
data.to_excel(r'C:\Users\gordo\Programming\Data_Bank\New_bank\_'+stocks+'.xlsx')

"""## NASDAQ"""

# Get the list of all available equity symbols from Nasdaq.

    # Returns nasdaq_tickers – 
        # DataFrame with company tickers, names, and other properties.
    # Return type pandas.DataFrame

pd.nasdaq_trader.get_nasdaq_symbols(retry_count=3, timeout=30,
                                    pause=None)

"""## INTRINO"""

import intrinio_sdk
import pandas as pd

intrinio_sdk.ApiClient().configuration.api_key['api_key'] = '{OjdlOTlkZjdkODk3MDY0YzkzMWMxZDM0NjIyZTMyZTYw}' 
security_api = intrinio_sdk.SecurityApi()

r = security_api.get_security_stock_prices(identifier='AAPL',
                                           start_date='2000-01-01',
                                           end_date='2010-12-31',
                                           frequency='daily',
                                           page_size=10000)
r=pd.DataFrame(r)
r

response_list = [x.to_dict() for x in r.stock_prices]
df_intrinio = pd.DataFrame(response_list).sort_values('date')
df_intrinio.set_index('date', inplace=True)

"""## quandl
Quandl has many data sources to get different types of data. However, some are free and some are paid. Wiki is the free data source of Quandl to get the data of the end of the day prices of 3000+ US equities.

It is curated by Quandl community and also provides information about the dividends and split.

To get the stock market data, you need to first install the quandl module if it is not already installed using the pip command as shown below.

####  Advantages
It is free of cost Has split and dividend-adjusted stock market data

#### Disadvantages
Only available till 27-March-2018

### cookbook
"""

import pandas as pd
import quandl

QUANDL_KEY = 'dbyBuiq4bczbbuz9bA4t'
quandl.ApiConfig.api_key = QUANDL_KEY

df_quandl = quandl.get(dataset='WIKI/AAPL',
                       start_date='2000-01-01',
                       end_date='2010-12-31',api_key=QUANDL_KEY)

df_quandl

"""### other data pulls"""

QUANDL_API_KEY = 'dbyBuiq4bczbbuz9bA4t'

# Set the start and end date
start_date = '1990-01-01'
end_date = '2018-03-01'

# Set the ticker name
ticker = 'AMZN'

# Feth the data
data = quandl.get('WIKI/'+ticker, start_date=start_date,
                  end_date=end_date, api_key=QUANDL_API_KEY)

# Print the first 5 rows of the dataframe
data.head()

# Define the figure size for the plot
plt.figure(figsize=(10, 7))

# Plot the adjusted close price
data['Adj. Close'].plot()

# Define the label for the title of the figure
plt.title("Adjusted Close Price of %s" % ticker, fontsize=16)

# Define the labels for x-axis and y-axis
plt.ylabel('Price', fontsize=14)
plt.xlabel('Year', fontsize=14)

# Plot the grid lines
plt.grid(which="major", color='k', linestyle='-.', linewidth=0.5)
plt.show()

"""### multi security pull"""

# Define the ticker list
tickers_list = ['AAPL', 'IBM', 'MSFT', 'WMT']

# Import pandas
data = pd.DataFrame(columns=tickers_list)

# Feth the data
for ticker in tickers_list:
    data[ticker] = quandl.get('WIKI/' + ticker, start_date=start_date,
                              end_date=end_date, api_key=QUANDL_API_KEY)['Adj. Close']

# Print first 5 rows of the data
data.head()

# Plot all the close prices
data.plot(figsize=(10, 7))

# Show the legend
plt.legend()

# Define the label for the title of the figure
plt.title("Adjusted Close Price", fontsize=16)

# Define the labels for x-axis and y-axis
plt.ylabel('Price', fontsize=14)
plt.xlabel('Year', fontsize=14)

# Plot the grid lines
plt.grid(which="major", color='k', linestyle='-.', linewidth=0.5)
plt.show()

pd.quandl.QuandlReader(symbols, start=None, end=None,
                       retry_count=3, pause=0.1,
                       session=None,chunksize=25,
                       api_key=None)

# Returns DataFrame of historical stock prices from symbol, 
    # over date range, start to end.

pd.quandl.QuandlReader(symbols, start=None, end=None,
                       retry_count=3, pause=0.1, session=None,
                       chunksize=25, api_key=None)

"""### main pulls"""

# QUANDL API FIXED-PARAMETERS

quandl.ApiConfig.api_key = 'VpYKj-e3pTXsUxQBMcto'


start_date=('2018-1-1')
end_date=('2020-1-1')

# SPECIFIC_DATE

SPECIFIC_DATE=quandl.get('FINRA/FORF_TLLTD', start_date='2018-06-22', end_date='2018-06-22')
SPECIFIC_DATE

# FILTER BY DATE_RANGE

DATE_RANGE=quandl.get('FINRA/FORF_TLLTD', start_date='2018-06-14', end_date='2018-06-22')
DATE_RANGE

# RETRIEVE Two_Columns

Two_Columns=quandl.get('FINRA/FORF_TLLTD', start_date=start_date, end_date=end_date, column_index='1')
Two_Columns

# RETRIEVE UNFILTERED TIME-SERIES

UNFILTERED=quandl.get('FINRA/FORF_TLLTD')
UNFILTERED

"""### (ZEFR)
* Zacks Expanded Fundamental Ratios
"""

# Exp Ratio F1 (Exp_Ratio_F1)

Exp_Ratio_F1 = quandl.get_table("ZACKS/RF1", paginate=True)
Exp_Ratio_F1

# Exp Ratio F160 
# Exp_Ratio_F160

Exp_Ratio_F160= quandl.get_table("ZACKS/RF160", paginate=True)
Exp_Ratio_F160

"""###  - Z_A_R
* Zacks Analyst Revisions
"""

# Zacks Earnings Estimate Revisions
        # Z_Earning_Est_Rev

Z_Earning_Est_Rev = quandl.get_table("ZACKS/EREV", paginate=True)
Z_Earning_Est_Rev

"""### Zacks Sales Surprises"""

# Zacks Master Table
    # Z_Master

Z_Master = quandl.get_table("ZACKS/MT", paginate=True)
Z_Master

# Zacks Sales Surprises
    # Z_Sales

Z_Sales = quandl.get_table("ZACKS/SS", paginate=True)
Z_Sales

"""### Zacks Fundamentals Collection C"""

# Zacks Master Table
    # Z_Master_c
    
Z_Master_c=data = quandl.get_table("ZACKS/MT", paginate=True)
Z_Master_c

# Zacks Fundamental Ratios
    # Z_Fund_Ratio_c
    
Z_Fund_Ratio_c=quandl.get_table("ZACKS/FR", paginate=True)
Z_Fund_Ratio_c

# Zacks Fundamentals Expanded
    # Z_Fund_Exp_C
    
Z_Fund_Exp_C=quandl.get_table("ZACKS/FE", paginate=True)
Z_Fund_Exp_C

"""### Zacks Fundamentals Collection B"""

# Zacks Fundamentals Condensed
    #Z_F_C_B

Z_F_C_B = quandl.get_table("ZACKS/FC", paginate=True)
Z_F_C_B

# Zacks Fundamental Ratios
    # Z_F_R_B
    
Z_F_R_B = quandl.get_table("ZACKS/FR", paginate=True)
Z_F_R_B

# Zacks Master Table
    # Z_M_T_B
    
Z_M_T_B = quandl.get_table("ZACKS/MT", paginate=True)
Z_M_T_B

"""### Zacks Fundamentals Collection A"""

# Zacks Fundamentals Condensed
    # Z_F_C_A
    
Z_F_C_A = quandl.get_table("ZACKS/FC", paginate=True)
Z_F_C_A

# Zacks Fundamental Ratios
    # Z_F_R_A
    
Z_F_R_A = quandl.get_table("ZACKS/FR", paginate=True)
Z_F_R_A

# Zacks Master Table
    # Z_M_T_A
    
Z_M_T_A = quandl.get_table("ZACKS/MT", paginate=True)
Z_M_T_A

"""### Sharadar Core US Equities Bundle"""

# Core US Fundamentals
    # Core_US_Fundamentals
    
Core_US_Fundamentals = quandl.get_table("SHARADAR/SF1", paginate=True)
Core_US_Fundamentals

# Tickers and Metadata
    # TIX_META
    
TIX_META = quandl.get_table("SHARADAR/TICKERS", paginate=True)
TIX_META

"""## IEX 
* https://addisonlynch.github.io/iexfinance/stable/index.html
* pd.iex.daily.IEXDailyReader(symbols=None, start=None,end=None, retry_count=3,pause=0.1, session=None, chunksize=25, api_key=None)

### GENERAL:

#### Passing as an Argument I.
"""

from iexfinance.refdata import get_symbols

get_symbols(output_format='pandas', token='pk_b740ad24ded147cca822e98ded174c3d')

a = Stock('TICKER', token='pk_b740ad24ded147cca822e98ded174c3d')

"""#### Passing as an Argument II."""

from iexfinance.stocks import Stock

a = Stock('AAPL', token='pk_b740ad24ded147cca822e98ded174c3d')
a.get_quote()

"""####  FORMATTING FOR PULLS:"""

start = datetime(2016, 9, 1)
end = datetime(2018, 9, 1)

IEX_API_KEY='pk_b740ad24ded147cca822e98ded174c3d'


f = web.DataReader('F', 'iex', start, end, api_key=IEX_API_KEY)

"""#### Fetch all stock symbols
* Returns a Pandas Dataframe of all stock symbols, names, and more.
* iexfinance.refdata.get_symbols(**kwargs)
"""

from iexfinance.refdata import get_symbols
get_symbols(token='pk_b740ad24ded147cca822e98ded174c3d')[:2]

from iexfinance.refdata import get_symbols

get_symbols(output_format='pandas', token='pk_b740ad24ded147cca822e98ded174c3d')

from iexfinance.stocks import Stock

aapl = Stock("AAPL", output_format='pandas', token='pk_b740ad24ded147cca822e98ded174c3d')
aapl.get_quote().head()

"""###  Available Data Points For a Symbol
* To obtain all available data points for a symbol, simply pass the symbol to get_data_points with no key:
"""

from iexfinance.data_apis import get_data_points

data_pts=(get_data_points("AAPL", token='pk_b740ad24ded147cca822e98ded174c3d'))
data_pts

"""####  Individual Data Points For a Symbol
* To obtain an individual data point for a single symbol, pass the symbol and the data point ID to get_data_points:
"""

import locale
from iexfinance.data_apis import get_data_points

data_pts1=get_data_points('AAPL', 'NETINCOME', token = 'pk_3e46a4b55bd04bd68bb778802602595b')

print('$'+f'{data_pts1:,}')

"""####  All Available Time Series
* To obtain a list of all available time series, simply call get_time_series with no parameters:
"""

from iexfinance.data_apis import get_time_series

get_time_series(token = 'pk_3e46a4b55bd04bd68bb778802602595b')

"""####  Individual Time Series
* Whereas calling get_time_series with no parameters returns a full inventory of time series endpoints
* calling get_time_series with an individual series ID and (optional) keys and subkeys as parameters.

* For example, to obtain the REPORTED_FINANCIALS time series entry for Apple Inc. (AAPL):
"""

get_time_series('REPORTED_FINANCIALS', 'AAPL', token = 'pk_3e46a4b55bd04bd68bb778802602595b')

    # OR WITH A SUB KEY
# get_time_series("REPORTED_FINANCIALS", "AAPL", "10-Q")

get_time_series("REPORTED_FINANCIALS", "AAPL", "10-K", last=1, token = 'pk_3e46a4b55bd04bd68bb778802602595b')

"""### Historical Data
* It's possible to obtain historical data using get_historical_data and get_historical_intraday.

#### Daily
* To obtain daily historical price data for one or more symbols, use the get_historical_data function. 
* This will return a daily time-series of the ticker requested over the desired date range 
    * (start and end passed as datetime.datetime objects):
"""

from datetime import datetime
from iexfinance.stocks import get_historical_data

start = datetime(2017, 1, 1)
end = datetime(2018, 1, 1)

df = get_historical_data("TSLA", start, end, token='pk_b740ad24ded147cca822e98ded174c3d')
df

# To obtain daily closing prices only (reduces message count), set close_only=True:
df = get_historical_data("TSLA", "20190617", close_only=True, token='pk_b740ad24ded147cca822e98ded174c3d')
df

# For Pandas DataFrame output formatting, pass output_format:
df = get_historical_data("TSLA", start, end, output_format='pandas', token='pk_b740ad24ded147cca822e98ded174c3d')

# It's really simple to plot this data, using matplotlib:
import matplotlib.pyplot as plt

df.plot()
plt.show()

"""#### Minutely (Intraday)
* To obtain historical intraday data, use get_historical_intraday as follows. 
* Pass an optional date to specify a date within three months prior to the current day (default is current date):
"""

from datetime import datetime
from iexfinance.stocks import get_historical_intraday

date = datetime(2018, 11, 27)

get_historical_intraday("AAPL", date, token='pk_b740ad24ded147cca822e98ded174c3d')

# or for a Pandas Dataframe indexed by each minute:

get_historical_intraday("AAPL", output_format='pandas', token='pk_b740ad24ded147cca822e98ded174c3d')

"""#### Real-time Quotes
* To obtain real-time quotes for one or more symbols, use the get_price method of the Stock object:
"""

from iexfinance.stocks import Stock
tsla = Stock('TSLA', token='pk_b740ad24ded147cca822e98ded174c3d')
tsla.get_price()

"""### Fundamentals

#### Balance Sheet
"""

from iexfinance.stocks import Stock

aapl = Stock("AAPL", token='pk_b740ad24ded147cca822e98ded174c3d')
aapl.get_balance_sheet()

"""#### Income Statement"""

aapl.get_income_statement()

"""#### Cash Flow"""

aapl.get_cash_flow()

"""#### Modeling/Valuation Tools
* Analyst Estimates
"""

from iexfinance.stocks import Stock

aapl = Stock("AAPL",, token='pk_b740ad24ded147cca822e98ded174c3d')

aapl.get_estimates()

"""#### Price Target"""

aapl.get_price_target()

"""#### Social Sentiment
* iexfinance.altdata.get_social_sentiment(symbol, period_type=None, date=None, **kwargs)
"""

from iexfinance.altdata import get_social_sentiment
get_social_sentiment("AAPL", token='pk_b740ad24ded147cca822e98ded174c3d')

"""####  CEO Compensation
* iexfinance.altdata.get_ceo_compensation(symbol, **kwargs)
"""

from iexfinance.altdata import get_ceo_compensation
get_ceo_compensation("AAPL", token='pk_b740ad24ded147cca822e98ded174c3d')

"""####  Fund and Institutional Ownership"""

from iexfinance.stocks import Stock
aapl = Stock("AAPL", token='pk_b740ad24ded147cca822e98ded174c3d')

# Fund ownership
aapl.get_fund_ownership()

# Institutional ownership
aapl.get_institutional_ownership()

"""#### List of Symbols IEX supports for API calls"""

from iexfinance.refdata import get_symbols

get_symbols()

"""### Account Usage"""

from iexfinance.account import get_usage

get_usage(quota_type='messages')

"""### MORE DATA PULL OPTIONS"""

# Returns DataFrame of historical stock prices from symbols,
    # over date range, start to end. To avoid being
    # penalized by IEX servers, pauses between downloading 
    # ‘chunks’ of symbols can be specified.

pd.iex.daily.IEXDailyReader(symbols=None, start=None,end=None,
                            retry_count=3,pause=0.1, 
                            session=None, chunksize=25, api_key=None)

# Daily statistics from IEX for a day or month

pd.iex.stats.DailySummaryReader(symbols=None, start=None,
                             end=None, retry_count=3,
                             pause=0.1, session=None)

# Monthly statistics from IEX

pd.iex.stats.MonthlySummaryReader(symbols=None, start=None,
                                  end=None, retry_count=3,
                                  pause=0.1, session=None)

# Retrieve order book data from IEX

pd.iex.deep.Deep(symbols=None, service=None, start=None,
                 end=None, retry_count=3, pause=0.1, session=None)

start = datetime(2016, 9, 1)
end = datetime(2018, 9, 1)

IEX_API_KEY='pk_b740ad24ded147cca822e98ded174c3d'


f = web.DataReader('F', 'iex', start, end, api_key=IEX_API_KEY)

f=pd.DataFrame(f.loc['2018-08-31'])
f

f = web.DataReader('goog', 'iex-tops')
f[:10]

"""## TINGO"""

pd.tiingo.TiingoDailyReader(symbols,start=None, end=None,
                            retry_count=3, pause=0.1,
                            timeout=30, session=None,
                            freq=None,api_key=None)

TIINGO_API_KEY='84d060da157bf79a157c6a9601dc46a28b62bc5c'

df = pdr.get_data_tiingo('GOOG', api_key=TIINGO_API_KEY)
df.head()

"""## Alpha Vantage
* Through the Alpha Vantage Time Series endpoints, it is possible to obtain historical equities data for individual symbols. For daily, weekly, and monthly frequencies, 20+ years of historical data is available. The past 3-5 days of
* intraday data is also available.
* Alpha vantage is used to get the minute level stock market data. You need to signup on alpha vantage to get the free API key.
"""

# Import TimeSeries class
from alpha_vantage.timeseries import TimeSeries
ALPHA_VANTAGE_API_KEY = '0R9QKMGY0T17LR42'

# Initialize the TimeSeries class with key and output format
ts = TimeSeries(key=ALPHA_VANTAGE_API_KEY, output_format='pandas')

# Get pandas dataframe with the intraday data and information of the data
data, data_info=ts.get_daily('ACBI', outputsize ='compact')

# Print the information of the data
data_info

# Print the intraday data
data.head()

data['4. close'].plot(figsize=(10, 7))

# Define the label for the title of the figure
plt.title("Close Price", fontsize=16)

# Define the labels for x-axis and y-axis
plt.ylabel('Price', fontsize=14)
plt.xlabel('Time', fontsize=14)

# Plot the grid lines
plt.grid(which="major", color='k', linestyle='-.', linewidth=0.5)
plt.show()

# Returns DataFrame of the Alpha Vantage Stock Time Series endpoints

pd.av.time_series.AVTimeSeriesReader(symbols=None,
                                     function=’TIME_SERIES_DAILY’,
                                     start=None, end=None,
                                     retry_count=3,
                                     pause=0.1, session=None,
                                     chunksize=25,api_key=None)

# Returns DataFrame of the Alpha Vantage Sector Performances SECTOR data
pd.av.sector.AVSectorPerformanceReader(symbols=None,start=None,
                                       end=None,retry_count=3,
                                       pause=0.1, 
                                       session=None,api_key=None)

"""### The following endpoints are available:
* av-intraday - Intraday Time Series
* av-daily - Daily Time Series
* av-daily-adjusted - Daily Time Series (Adjusted)
* av-weekly - Weekly Time Series
* av-weekly-adjusted - Weekly Time Series (Adjusted)
* av-monthly - Monthly Time Series
* av-monthly-adjusted - Monthly Time Series (Adjusted)
"""

# Historical Time Series Data

ALPHA_VANTAGE_API_KEY='1K573OJSLIUGLAGE'

tickers=['ACBI']

av_start=datetime(2017,1,1)
av_end=datetime(2020,1,1)

f = web.DataReader(tickers, "av-daily", start=av_start,end=av_end,
                   api_key=ALPHA_VANTAGE_API_KEY)

f

f = web.DataReader(["USD/JPY", "BTC/CNY"], "av-forex",
                   api_key=ALPHA_VANTAGE_API_KEY)
f

"""## YAHOO FINANCE (yfinance)
One of the first sources from which you can get daily price-volume stock market data is Yahoo finance. You can use pandas_datareader or yfinance module to get the data.

####   Advantages
Adjusted close price stock market data is available Most recent stock market data is available Doesn't require API key to fetch the stock market data

#### Disadvantages
It is not a stable source to fetch the stock market data If the stock market data fetching fails from yahoo finance using the pandas_datareader then you can use yfinance package to fetch the data.

##### yfinance is another module which can be used to fetch the minute level stock market data. It returns the stock market data for the last 7 days.

The yfinance module has the download method which can be used to download the stock market data. It takes the following parameters:

ticker: The name of the tickers you want the data for. If you want data for multiple tickers then separate them by space

period: The number of days/month of data required. The valid frequencies are 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max

interval: The frequency of data. The valid intervals are 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3mo

The below code fetches the stock market data for MSFT for the past 5 days of 1-minute frequency.

##### Featured Methods
get_financial_stmts(frequency, statement_type, reformat=True)
frequency can be either ‘annual’ or ‘quarterly’.
statement_type can be ‘income’, ‘balance’, ‘cash’ or a list of several.
reformat optional value defaulted to true. Enter False for unprocessed raw data from Yahoo Finance.
get_stock_price_data(reformat=True)
reformat optional value defaulted to true. Enter False for unprocessed raw data from Yahoo Finance.
get_stock_earnings_data(reformat=True)
reformat optional value defaulted to true. Enter False for unprocessed raw data from Yahoo Finance.
get_summary_data(reformat=True)
Returns financial summary data for cryptocurrencies, stocks, currencies, ETFs, mutual funds, U.S. Treasuries, commodity futures, and indexes.
reformat optional value defaulted to true. Enter False for unprocessed raw data from Yahoo Finance.
get_stock_quote_type_data()
get_historical_price_data(start_date, end_date, time_interval)
This method will pull historical pricing data for stocks, currencies, ETFs, mutual funds, U.S. Treasuries, cryptocurrencies, commodities, and indexes.
start_date should be entered in the ‘YYYY-MM-DD’ format and is the first day that data will be pulled for.
end_date should be entered in the ‘YYYY-MM-DD’ format and is the last day that data will be pulled for.
time_interval can be either ‘daily’, ‘weekly’, or ‘monthly’. This variable determines the time period interval for your pull.
Data response includes relevant pricing event data such as dividends and stock splits.
get_num_shares_outstanding(price_type=’current’)
price_type can also be set to ‘average’ to calculate the shares outstanding with the daily average price.

##### Additional Module Methods
get_interest_expense()
get_operating_income()
get_total_operating_expense()
get_total_revenue()
get_cost_of_revenue()
get_income_before_tax()
get_income_tax_expense()
get_gross_profit()
get_net_income_from_continuing_ops()
get_research_and_development()
get_current_price()
get_current_change()
get_current_percent_change()
get_current_volume()
get_prev_close_price()
get_open_price()
get_ten_day_avg_daily_volume()
get_three_month_avg_daily_volume()
get_stock_exchange()
get_market_cap()
get_daily_low()
get_daily_high()
get_currency()
get_yearly_high()
get_yearly_low()
get_dividend_yield()
get_annual_avg_div_yield()
get_five_yr_avg_div_yield()
get_dividend_rate()
get_annual_avg_div_rate()
get_50day_moving_avg()
get_200day_moving_avg()
get_beta()
get_payout_ratio()
get_pe_ratio()
get_price_to_sales()
get_exdividend_date()
get_book_value()
get_ebit()
get_net_income()
get_earnings_per_share()
get_key_statistics_data()
"""

ydata = yf.download(tickers="MSFT",
 period="5d",
 interval="1m")
ydata.head()

"""###  Stocks Fundamental Data
We have used yfinance to get the fundamental data.

The first step is to set the ticker and then call the appropriate properties to get the right stock market data.
"""

# Set the ticker as MSFT
!pip install yfinance

# Import yfinance
import yfinance as yf

# Set the ticker as MSFT
y_finance = yf.Ticker("MSFT")


#yticker='MSFT'
#y_finance=yf.Ticker(yticker)

"""### Key Ratios
You can fetch the latest price to book ratio and price to earnings ratio as shown below.
"""

# get price to book
pb = y_finance.info['priceToBook']
pe = y_finance.info['regularMarketPrice']/y_finance.info['trailingEps']

print('Price to Book Ratio is: %.2f' % pb)
print('Price to Earnings Ratio is: %.2f' % pe)
print('')

#or
ptb=y_finance.info['priceToBook']
print(ptb)

# show revenues

revenue = y_finance.info['enterpriseToRevenue']

revenue

#plt.bar(revenue.index, revenue.values)
#plt.ylabel("Total Revenues")
#plt.show()

# Earnings Before Interest and Taxes

EBIT = y_finance.info['enterpriseToEbitda']

EBIT

#plt.bar(EBIT,'years')
#plt.ylabel("EBIT")
#plt.show()

# show income statement
y_finance.financials

# show balance heet
y_finance.balance_sheet

# show cashflow
y_finance.cashflow

# show other info
y_finance.info

"""### more data pulls"""

# Plot the adjusted close price
data['Adj Close'].plot(figsize=(10, 7))

# Define the label for the title of the figure
plt.title("Adjusted Close Price of %s" % ticker, fontsize=16)

# Define the labels for x-axis and y-axis
plt.ylabel('Price', fontsize=14)
plt.xlabel('Year', fontsize=14)

# Plot the grid lines
plt.grid(which="major", color='k', linestyle='-.', linewidth=0.5)

# Show the plot
plt.show()

start = datetime(2016, 12, 31)
end = datetime.now()

stock_data = data.DataReader(["SBUX", "SHOP", "BIDU", "WDAY", "WIX",],
                             'yahoo', start, end)

stock_data=pd.DataFrame(stock_data['Adj Close'])
stock_data

stock_data_closing_prices = stock_data
stock_data_closing_prices.plot()
plt.xlabel("Date")
plt.ylabel("Adjusted Closing Price")
plt.title("Tech Stocks Adjusted Price Over Time")
plt.show()

"""# DATA VISUALIZATION

## Plot Portfolio
"""

start = datetime(2016, 12, 31)
end = datetime.now()

stock_data = data.DataReader(["SBUX", "SHOP", "BIDU", "WDAY", "WIX",],
                             'yahoo', start, end)

stock_data=pd.DataFrame(stock_data['Adj Close'])
stock_data

stock_data_closing_prices = stock_data
stock_data_closing_prices.plot()
plt.xlabel("Date")
plt.ylabel("Adjusted Closing Price")
plt.title("Tech Stocks Adjusted Price Over Time")
plt.show()

stock_data_daily_returns = stock_data.pct_change()
stock_data_daily_returns.plot()
plt.xlabel("Date")
plt.ylabel("ROR")
plt.title("Daily Simple Rate of Return Over time")
plt.figure(figsize=(16,9))
plt.show()

fig = plt.figure(figsize=(15,15))
ax1 = fig.add_subplot(321)
ax2 = fig.add_subplot(322)
ax3 = fig.add_subplot(323)
ax4 = fig.add_subplot(324)
ax5 = fig.add_subplot(325)



ax1.plot(stock_data['SBUX'].pct_change())
ax1.set_title("SBUX")
ax2.plot(stock_data['SHOP'].pct_change())
ax2.set_title("SHOP")
ax3.plot(stock_data['BIDU'].pct_change())
ax3.set_title("BIDU")
ax4.plot(stock_data['WDAY'].pct_change())
ax4.set_title("WDAY")
ax5.plot(stock_data['WIX'].pct_change())
ax5.set_title("WIX")
plt.tight_layout()
plt.show()

"""## GRAPH DAILY MEAN"""

# calculate daily mean
daily_mean = stock_data_daily_returns.mean()
daily_mean1=pd.DataFrame(daily_mean)

# daily mean index for the x axis
daily_mean.keys()

# grab each daily mean value for the y axis
height = []
for key in daily_mean.keys():
    height.append(daily_mean[key])

# arrange keys on x axis based on length
x_pos = np.arange(len(daily_mean.keys()))


# plot bars
plt.bar(x_pos, height)
 
# create names on the x-axis
plt.xticks(x_pos, daily_mean.keys())

# label chart
plt.xlabel("Tech_Stocks")
plt.ylabel("daily mean")
plt.title("daily mean rate of return")

# show graphic
plt.show()

daily_mean1

"""## VARIANCE"""

# calculate variance
daily_var = stock_data_daily_returns.var()
daily_var1=pd.DataFrame(daily_var)

# variance index for the x axis
daily_var.keys()

# grab each variance value for the y axis
height = []
for key in daily_var.keys():
    height.append(daily_var[key])
    
# arrange keys on x axis based on length
x_pos = np.arange(len(daily_var.keys()))



# plot bars
plt.bar(x_pos, height)
 
# create names on the x-axis
plt.xticks(x_pos, daily_var.keys())

# label chart
plt.xlabel("Tech_Stocks")
plt.ylabel("variance")
plt.title("daily variance")

# show graphic
plt.show()

daily_var1

"""## STANDARD DEVIATION (STD)"""

# calculate standard deviation
daily_std = stock_data_daily_returns.std()
daily_std1=pd.DataFrame(daily_std)

# standard deviation index for the x axis
daily_var.keys()

# grab each standard deviation value for the y axis
height = []
for key in daily_std.keys():
    height.append(daily_std[key])
    
# arrange keys on x axis based on length
x_pos = np.arange(len(daily_std.keys()))


# plot bars
plt.bar(x_pos, height)
 
# create names on the x-axis
plt.xticks(x_pos, daily_std.keys())

# label chart
plt.xlabel("Tech_Stocks")
plt.ylabel("std")
plt.title("daily std")

# show graphic
plt.show()

daily_std1

"""# RATIO ANALYSIS
* some short description about this section

1. Daily Mean
    - 
2. Concept
3. concept

## DAILY MEAN RoR
"""

# calculate daily mean
daily_mean = stock_data_daily_returns.mean()
daily_mean1=pd.DataFrame(daily_mean)

daily_mean1

"""## variance"""

# calculate variance
daily_var = stock_data_daily_returns.var()
daily_var1=pd.DataFrame(daily_var)
daily_var1

"""## Standard Deviation"""

# calculate standard deviation
daily_std = stock_data_daily_returns.std()
daily_std1=pd.DataFrame(daily_std)
daily_std1

"""## PORTFOLIO CORRELATION"""

stock_data_daily_returns.corr()

"""# STRATEGIES

## PAIRS TRADING STRATEGY
"""

# Initializing variables

data = []
headers = ['Date','commodity1','commodity2','zscore','signal','status',\
              'buy price','sell price','mtm','pnl','Cointegration test']
data.append(headers)
threshold = 1.75    # Tolerance for the stdev above and below the mean
start=80
end=90
prev_status = ""
mtm = ""
prev_sell_price = ""
sell_price = ""
prev_buy_price = ""
buy_price = ""
SL = -10000      # Stop loss
TP = 20000       # Take profit
N=5000           # Lot size for data1
M=5000           # Lot size for data2

from quantrautil import get_quantinsti_api_key

# To get your API key, sign up for a free Quandl account.
# Then, you can find your API key on Quandl account settings page.

key = get_quantinsti_api_key()

data1 = quandl.get("CHRIS/MCX_AL1", start_date="2014-04-01", \
                   end_date="2016-07-01", api_key= key)
data2 = quandl.get("CHRIS/MCX_PB1", start_date="2014-04-01", \
                   end_date="2016-07-01", api_key= key)

QUANDL_API_KEY = 'VpYKj-e3pTXsUxQBMcto'

# Set the start and end date
start_date = '1990-01-01'
end_date = '2018-03-01'

# Set the ticker name
ticker = 'AMZN'

# Feth the data
data1 = quandl.get("CHRIS/MCX_AL1", start_date="2014-04-01", \
                   end_date="2016-07-01", api_key= QUANDL_API_KEY)
data2 = quandl.get("CHRIS/MCX_PB1", start_date="2014-04-01", \
                   end_date="2016-07-01", api_key= QUANDL_API_KEY)


# Print the first 5 rows of the dataframe
data

# Drop nan columns
data1 = data1.dropna()
data2 = data2.dropna()

# To make the data uniform date wise
data1['key']=data1.index
data2['key']=data2.index

# Merge dataframes to find common dates
result = pd.merge(data1, data2, on='key', left_index=True, right_index=False)

data1 = result[['Open_x','High_x','Low_x','Close_x','Volume_x']] 
data2 = result[['Open_y','High_y','Low_y','Close_y','Volume_y']]

data1.columns = ['Open','High','Low','Close','Volume'] # Rename the columns

data2.columns = ['Open','High','Low','Close','Volume'] # Rename the columns

# Define cointegration test function

# Use OLS method to find the spread of the two series
# Check for stationarity of the spread using adfuller test

def cointegration_test(x, y):
    result = stat.OLS(x['Close'], y['Close']).fit()   
    return ts.adfuller(result.resid)

# Define z-score calculation function
def zscore_cal(data1,data2,start,end):
    s1 = pd.Series(data1['Close'][start:end])
    s2 = pd.Series(data2['Close'][start:end])

    mvavg_old = np.mean(np.log(s1/s2))  # Compute mean of the spread till now

    std_old = np.std(np.log(s1/s2))    #  Compute stdev of the spread till now
    
    current_spread = np.log(data1['Close'][end]/data2['Close'][end])   # Compute spread
    
    # This is the same as current_spread = np.log(data1['Close'][end]) - np.log(data2['Close'][end])
    
    zscore = (current_spread - mvavg_old)/std_old if std_old > 0 else 0  # Compute z-score

    return zscore

# Generating trading signals
def signal_cal(zscore,threshold,adftest):
    if zscore > threshold and adftest == 'Yes': 
        signal = 'SELL' # Z-score is greater than threshold, the spread shall fall towards mean

    elif zscore < -threshold and adftest == 'Yes':
        signal = 'BUY' # Z-score is smaller than threshold, the spread shall rise towards mean
    else:
        signal = ''
    return signal

# Defining status
def status_cal(prev_status,mtm,SL,TP,signal,adftest):
    if prev_status in ["","SL","TP","CB"]:
        status = signal
    else:
        if adftest == "No":
            status = "CB"   # Break in the cointegration status of the pair
        else:
            if mtm == "":
                status = ""
            else:
                if mtm<SL:
                    status="SL"   # Stop loss status
                else:
                    if mtm>TP:
                        status="TP"  # Take profit status
                    else:
                        status = prev_status

    return status

# Calculating buy price
def buy_price_cal(prev_status,prev_buy_price,buy_price,signal,status,data1, data2,end):
    if status == prev_status:
        buy_price = prev_buy_price
    else:
        if status in ["SL","TP","CB",""]:
            buy_price = ""
        else:
            if signal == "BUY":    # Signal is to buy the spread
                buy_price = data1['Close'][end]  # Hence, buy price = close of first security
            else:
                if signal == "SELL":  # Signal is to sell the spread
                    buy_price = data2['Close'][end]  # Hence, buy price = close of second security
                else:
                    buy_price = ""   # no signal hence no buy price

    return buy_price

# Calculating sell price
def sell_price_cal(prev_status,prev_sell_price,sell_price,signal,status, data1,data2,end):
    if status == prev_status:
        sell_price = prev_sell_price
    else:
        if status in ["SL","TP","CB",""]:
            sell_price = ""
        else:
            if signal == "BUY":  # Signal is to buy the spread
                sell_price = data2['Close'][end] # Hence sell price = close of second security
            else:
                if signal == "SELL": # signal is to sell the spread
                    sell_price = data1['Close'][end] # Hence sell price = close of first security
                else:
                    sell_price = "" # No signal hence no sell price either

    return sell_price

# Calculating mtm
def mtm_cal(data1,data2,prev_status,prev_sell_price,prev_buy_price,M,N,end):
    if prev_status == "BUY":
        mtm = (prev_sell_price-data2['Close'][end])*M + (data1['Close'][end]-\
               prev_buy_price)*N  # Calculate mtm of the trades using their lot sizes
    else:
        if prev_status == "SELL":
            mtm =(prev_sell_price-data1['Close'][end])*N +(data2['Close'][end]\
                   -prev_buy_price)*M    # Calculate mtm of the trades using their lot sizes
        else:
            mtm = ""

    return mtm

# Defining the strategy function to execute the pairs trading program
def strategy(data1,data2,threshold,start,end,prev_status,mtm,prev_sell_price,\
             sell_price,prev_buy_price,buy_price,SL,TP,M,N):
    pnl = 0
    i = 0
    for row in data1[90:].iterrows():

         # Running the ADF test for each day, starting from day 91
        d1 = data1[i:90+i]
        d2 = data2[i:90+i]
        c_t = cointegration_test(d1, d2)
        if c_t[0] <= c_t[4]['10%'] and c_t[1] <= 0.1:
            adftest = "Yes"
        else:
            adftest = "No"
   
        # Calculating z-score
        zscore = zscore_cal(data1,data2,start,end)

        # Generating trading signals
        signal = signal_cal(zscore,threshold,adftest)

        # Calculating mtm
        mtm = mtm_cal(data1,data2,prev_status,prev_sell_price,\
                      prev_buy_price,M,N,end)

        # Assigning status
        status = status_cal(prev_status,mtm,SL,TP,signal,adftest)

        # Assigning buy_price
        buy_price = buy_price_cal(prev_status,prev_buy_price,buy_price,\
                                  signal,status,data1,data2,end)


        # Assigning sell_price
        sell_price = sell_price_cal(prev_status,prev_sell_price,sell_price,\
                                    signal,status,data1,data2,end)

        # Calculating pnl
        pnl = (pnl + mtm) if status in ["TP","SL","CB"] else pnl

        # Assigning prev values
        prev_sell_price = sell_price
        prev_status = status
        prev_buy_price = buy_price

        # Appending calculations to the data array
        data.append([str(data1.index[end])[:10],data1['Close'][end],\
                         data2['Close'][end],zscore,signal,status,buy_price,\
                         sell_price,mtm,pnl,adftest])

        # Incrementing variables to consider the next set of data
        end = end+1
        start = start+1
        i = i+1
        
    pyexcel.save_as(array = data, dest_file_name = \
                        'pair_strategy_without_zipline-90.csv')  # Save to CSV for debugging

fig,ax = plt.subplots(1,1,figsize = (10,5))

# Plot data1.Close
ax.plot(data1.index, data1.Close, label ='Aluminium') 

# Plot data2.Close
ax.plot(data2.index, data2.Close, label ='Lead') 

plt.legend() # Let matplotlib choose best location for legend
plt.xlabel('Date', fontsize = 20)
plt.ylabel('Close Prices', fontsize = 20)
plt.title('Aluminium and Lead Close Prices', fontsize = 20)

plt.grid() # Display the major grid
plt.tight_layout()
plt.show() # Finally display the plot

fig,ax = plt.subplots(1,1,figsize = (10,5))

# Plot the spread
ax.plot(data2.index, np.log(data1.Close.values/data2.Close.values), label = 'Spread') 

plt.legend()
plt.xlabel('Date', fontsize = 20)
plt.ylabel('Spread', fontsize = 20)
plt.title('Spread of Aluminium and Lead Close Prices', fontsize = 20)
plt.grid() 
plt.tight_layout()
plt.show()

# Run the strategy
strategy(data1,data2,threshold,start,end,prev_status,mtm,prev_sell_price,\
             sell_price,prev_buy_price,buy_price,SL,TP,M,N) 

result = pd.DataFrame(data, columns=headers)[1:] # Ignore the first row
result.set_index('Date',inplace=True)  # Set Date column as index for better plotting
result.index = pd.to_datetime(result.index) # Convert index to a datetime index

result.pnl.plot(figsize=(10,5), label ='PnL') 
plt.legend() 
plt.ylabel('PnL')
plt.title('PnL')
plt.grid() 
plt.tight_layout()
plt.show()

"""## INCOME STMT ANALYSIS (with waterfall chart)"""

def selectquote(quote): 
    r= requests.get(f"https://financialmodelingprep.com/api/v3/financials/income-statement/{quote}?period=quarter") 
    r = r.json() 
    stock = r['financials']
    stock = pd.DataFrame.from_dict(stock) 
    stock = stock.T   
    stock.columns = stock.iloc[0]
    stock.reset_index(inplace=True) 
    return stock 

selectquote('AAPL')

def selectquote1(quote):
    r= requests.get(f"https://financialmodelingprep.com/api/v3/financials/income-statement/{quote}?period=quarter")
    r = r.json()
    stock = r['financials']
    stock = pd.DataFrame.from_dict(stock)
    stock = stock.T
    stock.columns = stock.iloc[0]
    stock.reset_index(inplace=True)
    stock = stock.iloc[:,0:2]
    stock.rename(columns={ stock.columns[1]: quote }, inplace = True)
    cols = stock.columns.drop('index')
    stock = stock.iloc[1:,]
    return stock

selectquote1('AAPL')

r=requests.get("https://financialmodelingprep.com/api/v3/financials/income-statement/AAPL?period=quarter")
r=r.json()
d=r['financials']
count=0
for item in d:
    if count ==0:
        d=r['financials']
        d=d[0]
        incomeinitial=pd.DataFrame(list(d.items()),columns=['item','value'])
    count=count+1
    if count>5:
        continue
    d=r['financials']
    d=d[count]
    
    incomeinitial2=pd.DataFrame(list(d.items()),columns=['item','value'])
    incomeinitial=incomeinitial.merge(incomeinitial2,on="item",how='left')
    
incomeinitial=pd.DataFrame(list(d.items()),columns=['item','value'])
incomeinitial.columns=incomeinitial.iloc[0]
incomeinitial=incomeinitial[1:]
incomeinitial
cols=incomeinitial.columns
cols=cols[1:]

Revenue = incomeStatement[incomeStatement['index'] == 'Revenue'].iloc[0][1]
COGS = incomeStatement[incomeStatement['index'] == 'Cost of Revenue'].iloc[0][1]*-1
grossProfit = incomeStatement[incomeStatement['index'] == 'Gross Profit'].iloc[0][1] 
RD = incomeStatement[incomeStatement['index'] == 'R&D Expenses'].iloc[0][1]*-1 
GA = incomeStatement[incomeStatement['index'] == 'SG&A Expense'].iloc[0][1]*-1
operatingExpenses = incomeStatement[incomeStatement['index'] == 'Operating Expenses'].iloc[0][1]*-1 
interest = incomeStatement[incomeStatement['index'] == 'Interest Expense'].iloc[0][1]*-1
EBT = incomeStatement[incomeStatement['index'] == 'Earnings before Tax'].iloc[0][1]
incTax = incomeStatement[incomeStatement['index'] == 'Income Tax Expense'].iloc[0][1]*-1
netIncome = incomeStatement[incomeStatement['index'] == 'Net Income'].iloc[0][1]

fig = go.Figure(go.Waterfall(
    name = "20", orientation = "v",
    measure = ["relative", "relative", "total", "relative", "relative", "total","relative","total","relative","total"],

    x = ["Revenue", "COGS", "Gross Profit", "RD", "G&A", "Operating Expenses","Interest Expense", "Earn Before Tax","Income Tax","Net Income"],
    textposition = "outside",

    text = [Revenue/100000, COGS/100000, grossProfit/100000, RD/100000, GA/1000000, operatingExpenses/1000000,Interest/100000, EBT/100000,incTax/100000, NetIncome/100000],

     y = [Revenue, COGS, grossProfit, RD, GA, operatingExpenses, Interest,EBT,incTax,NetIncome],

    connector = {"line":{"color":"rgb(63, 63, 63)"}},
     
fig.update_layout(
         title = "Profit and loss statement",
         showlegend = True
 )))

fig.show()

print('Here Is The Financial Report For: AAPL')
incomeinitial

"""## Portfolio Allocation and Sharp Ratio"""

# . . . . . . . . . . DEFINE 5 SECURITIES TO LOOKUP . . . . . . . . . .
s1=input('Enter Ticker 1: ')
s2=input('Enter Ticker 2: ')
s3=input('Enter Ticker 3: ')
s4=input('Enter Ticker 4: ')

# . . . . . . . . . . ASSIGN ASSETS TO LONG STRING 'STOCKS' . . . . . . . . . .
stocks=(s1+'_'+s2+'_'+s3+'_'+s4)

start = datetime(2015, 1, 1)
end = datetime.now()

quandl.ApiConfig.api_key = 'zdZRZgzAuK8P2AnsZhU3'
data_df_1 = quandl.get('WIKI/' + s1+'.11', start_date=start, end_date=end, api_key = 'zdZRZgzAuK8P2AnsZhU3')
data_df_2 = quandl.get('WIKI/' + s2+'.11', start_date=start, end_date=end, api_key = 'zdZRZgzAuK8P2AnsZhU3')
data_df_3 = quandl.get('WIKI/' + s3+'.11', start_date=start, end_date=end, api_key = 'zdZRZgzAuK8P2AnsZhU3')
data_df_4 = quandl.get('WIKI/' + s4+'.11', start_date=start, end_date=end, api_key = 'zdZRZgzAuK8P2AnsZhU3')


data_price_1 = data_df_1['Adj. Close'].values
data_np_1 = data_df_1.values

data_price_2 = data_df_2['Adj. Close'].values
data_np_2 = data_df_2.values

data_price_3 = data_df_3['Adj. Close'].values
data_np_3 = data_df_3.values

data_price_4 = data_df_4['Adj. Close'].values
data_np_4 = data_df_4.values


data_df_1.to_csv(r'C:\Users\gordo\CODE_BUILDING\Real_Time_Stock_Market_Data\Portfolio_Allocation_Sharp_Ratio\quandl_data_'+s1+'.csv')
data_df_2.to_csv(r'C:\Users\gordo\CODE_BUILDING\Real_Time_Stock_Market_Data\Portfolio_Allocation_Sharp_Ratio\quandl_data_'+s2+'.csv')
data_df_3.to_csv(r'C:\Users\gordo\CODE_BUILDING\Real_Time_Stock_Market_Data\Portfolio_Allocation_Sharp_Ratio\quandl_data_'+s3+'.csv')
data_df_4.to_csv(r'C:\Users\gordo\CODE_BUILDING\Real_Time_Stock_Market_Data\Portfolio_Allocation_Sharp_Ratio\quandl_data_'+s4+'.csv')

for df_stock in (data_df_1,data_df_2,data_df_3,data_df_4):
    df_stock['Normalize Return'] = df_stock['Adj. Close']/df_stock.iloc[0]['Adj. Close']
#print(s1)
#data_df_1

for df_stock in (data_df_1,data_df_2,data_df_3,data_df_4):
    df_stock['Normalize Return'] = df_stock['Adj. Close']/df_stock.iloc[1]['Adj. Close']

#print(s2)
#data_df_2

for df_stock in (data_df_1,data_df_2,data_df_3,data_df_4):
    df_stock['Normalize Return'] = df_stock['Adj. Close']/df_stock.iloc[2]['Adj. Close']

#print(s3)
#data_df_3

for df_stock in (data_df_1,data_df_2,data_df_3,data_df_4):
    df_stock['Normalize Return'] = df_stock['Adj. Close']/df_stock.iloc[3]['Adj. Close']

#print(s4)
#data_df_4

# INPUT ALLOCATIONS PER ASSET

s1_allocate=input('Enter Allocation In Decimal Format - (0.3) : ')
s1_a=float(s1_allocate)

s2_allocate=input('Enter Allocation In Decimal Format - (0.3) : ')
s2_a=float(s2_allocate)

s3_allocate=input('Enter Allocation In Decimal Format - (0.3) : ')
s3_a=float(s3_allocate)

s4_allocate=input('Enter Allocation In Decimal Format - (0.3) : ')
s4_a=float(s4_allocate)

for df_stock,allocation in zip([data_df_1,data_df_2,data_df_3,data_df_4],[s1_a,s2_a,s3_a,s4_a]):
    df_stock['Allocation'] = df_stock['Normalize Return']*allocation

#print(s1)
#data_df_1

for df_stock in [data_df_1,data_df_2,data_df_3,data_df_4]:
    df_stock['Position Values'] = df_stock['Allocation']*10000

print(s1)
data_df_1

portfolio_val = pd.concat([data_df_1['Position Values'],data_df_2['Position Values'],data_df_3['Position Values'],data_df_4['Position Values']],axis=1)

portfolio_val.columns = [s1,s2,s3,s4]
portfolio_val

portfolio_val['Total Pos'] = portfolio_val.sum(axis=1)
portfolio_val

portfolio_val['Total Pos'].plot(figsize=(10,8))
plt.title('Total Portfolio Value')

portfolio_val.drop('Total Pos',axis=1).plot(kind='line')

"""## Quantitative Value Strategy

### Define The Method To Extract Fundamental Data
"""

def get_fundamental_data(df):
    for symbol in df.index:

        url = ("http://finviz.com/quote.ashx?t=" + symbol.lower())
        soup = bs(requests.get(url).content)  # , features='html5lib')
        for m in df.columns:
            try:
                df.loc[symbol, m] = fundamental_metric(soup, m)
            except Exception as e:
                print(symbol, 'not found')
                print(e)
                break
    return df

def fundamental_metric(soup, metric):
    return soup.find(text=metric).find_next(class_='snapshot-td2').text

"""### Define A List Of Stocks And The Fundamental Metrics"""

stock_list = ['AMZN', 'GOOG', 'AXL', 'FB', 'TSLA', 'WMT', 'DIS','KO', 'PEP', '', 'FICO', 'AMD', 'IBM', 'AAPL', 'LPL']

metric = ['P/B',
'P/E',
'Forward P/E',
'PEG',
'Debt/Eq',
'EPS (ttm)',
'Dividend %',
'ROE',
'ROI',
'EPS Q/Q',
'Insider Own'
]

df = pd.DataFrame(index=stock_list,columns=metric)
df = get_fundamental_data(df)

print('')
print("All stocks with fundamental data")

df

"""### Businesses which are quoted at low valuations
* P/E < 20
* P/B < 3
"""

try:
    df = df[(df['P/E'].astype(float) < 20) & (df['P/B'].astype(float) < 3)]
except:
    pass

"""### Businesses which have demonstrated earning power
* EPS Q/Q > 10%
"""

try:
    df['EPS Q/Q'] = df['EPS Q/Q'].map(lambda x: x[:-1])
    df = df[df['EPS Q/Q'].astype(float) > 10]
except:
    pass

"""### Businesses earning good returns on equity while employing little or no debt
* Debt/Eq < 1
* ROE > 10%
"""

try:
    df['ROE'] = df['ROE'].map(lambda x: x[:-1])
    df = df[(df['Debt/Eq'].astype(float) < 1) & (df['ROE'].astype(float) > 10)]
except:
    pass

"""### Management having substantial ownership in the business
* Insider own > 30%
"""

try:
    df['Insider Own'] = df['Insider Own'].map(lambda x: x[:-1])
    df = df[df['Insider Own'].astype(float) > 30]
except:
    pass

print("Stocks after screening")
df

"""# ALPHA & BETA MARKET ANALYSIS"""

start='2019-1-1'
end='2020-1-1'

yf.pdr_override()

df1=pdr.get_data_yahoo("GOOG", start, end)
df2=pdr.get_data_yahoo("SPY", start, end)

df1
#df2

"""## GOAL = Obtain Percent Change [.pct_change()]
Also, do NOT want to obtain first (0th) element because that will result in NaN
"""

return_goog=df1.Close.pct_change()[1:]
return_spy=df2.Close.pct_change()[1:]

"""## PLOT Returns Versus
We will plot the returns of Google and S&P500 against each other
"""

plt.figure(figsize=(20,10))
return_goog.plot()
return_spy.plot()
plt.ylabel("Daily Return of GOOG and SPY")
plt.show()

"""## Capital Asset Pricing Model or CAPM (How to Calculate Beta)
* One of the most common ways to calculate beta is using the Capital Asset Pricing Model or CAPM.
- Have a look at the CAPM model:
    - E (Ra) = Rf + Ba [ E (Rm) - Rf]
    
* CAPM model states that the expected return of an asset ‘E (Ra)’ is equal to the risk-free return in the market plus the difference between the expected return of the market and risk-free rate ‘[E (Rm) - Rf]’ multiplied by the asset’s beta  ‘Ba’.

* If we have all the values except the asset’s beta, we can calculate the beta using:
       -  Ba = [E (Ra) - Rf] / [ E (Rm) - Rf]
       
* We can even find beta by performing the ‘regression analysis’. 

* When one tries to capture a mathematical relationship between ‘x’ and ‘y’ variables, by fitting a line, polynomial or a curve through scatter plots, such that one can make a reasonably good prediction of  ‘y’ given ‘x’, then the mathematical process of deriving such an equation between x and y is called the regression analysis.This equation can also arrived at by using a machine learning based regression model.

* If we try to fit a ‘line’ through this scatter plot that “best” explains the observed values of ‘y’ in terms of observed values of ‘x’, we get a simple linear regression model.

* Linear regression assumes a linear relationship between the dependent and independent variables. 

* The following regression equation describes that relation:
    - Yi = b0 + b1 Xi + ei

* We refer to the intercept ‘b0’ and slope coefficient ‘b1’ as the regression coefficients and ei as the random error.
    - Rasset = ex-post alpha + beta of asset *  Rbenchmark  + ei
    
* To understand the coefficients more intuitively, if we consider the returns for Google vs. S&P 500 index, then the slope coefficient in a regression line is called the stock’s beta, as it measures the relative amount of systematic or undiversifiable risk in Google’s returns. 

* If the slope of Google returns is more than 1, its returns tend to increase or decrease more than the market returns. A slope or beta of 1 would have the same level of systematic risk as that of the market on an average, and a slope or beta less than 1 implies that the returns increase or decrease by less than the change in the market returns.

* The intercept term is the ex-post alpha i.e. the measure of excess returns of Google as compared to market index returns. If the intercept term is negative, it means Google has underperformed S&P on a risk adjusted basis and a positive intercept means it has had excess returns on risk adjusted basis.

* All the points on the regression equation line, predict the ‘y’ values for the corresponding ‘x’ values. However, the optimal regression line is the one for which the sum of the squared differences (vertical distances) or the sum of squared errors or SSE between the ‘y’ values predicted by the regression equation/line and the actual ‘y’ values is minimal.

* Thus, the regression line minimizes the SSE. This is the reason why simple linear regression is also called as Ordinary Least Squares or OLS, and the estimated (predicted) values by the regression equation i.e. y predicted are called least squares estimates.

* The slope coefficient ‘b1’ of the regression line is calculated as the covariance of x and y divided by the variance of x (covxy /σ2x ), and the intercept coefficient is the line's intersection with the y axis at x = 0.
"""

import statsmodels.api as sm
from statsmodels import regression

X=return_spy.values
Y=return_goog.values

def linreg(x,y):
    x=sm.add_constant(x)
    model=regression.linear_model.OLS(y,x).fit()
    
    # REMOVE THE CONSTANT
    x=x[:,1]
    return model.params[0], model.params[1]

alpha, beta = linreg(X,Y)
print('alpha: '+str(alpha))
print('')
print('beta: '+str(beta))

"""## LINEAR REGRESSION PLOT"""

X2 = np.linspace(X.min(), X.max(), 100)
Y_hat = X2 * beta + alpha

plt.figure(figsize=(10,7))
plt.scatter(X, Y, alpha=0.3) # PLOTS RAW DATA

plt.xlabel('S&P 500 Daily Return')
plt.ylabel('GOOG Daily Return')

plt.plot(X2, Y_hat, 'r', alpha=0.9)

plt.show()